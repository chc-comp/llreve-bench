(set-info :origin "Horn problem converted to SMT-LIB2 using Eldarica (https://github.com/uuverifiers/eldarica)")
(set-logic HORN)
(declare-fun INV_REC_tr^tr (Int Int Int Int) Bool)
(declare-fun INV_REC_tr^tr_PRE (Int Int) Bool)
(declare-fun INV_REC_tr__1 (Int Int) Bool)
(declare-fun INV_REC_tr__1_PRE (Int) Bool)
(declare-fun INV_REC_tr__2 (Int Int) Bool)
(declare-fun INV_REC_tr__2_PRE (Int) Bool)
(declare-fun INV_42 (Int Int Int Int) Bool)
(declare-fun INV_42_PRE (Int Int) Bool)
(declare-fun INV_42__1 (Int Int) Bool)
(declare-fun INV_42__1_PRE (Int) Bool)
(declare-fun INV_42__2 (Int Int) Bool)
(declare-fun INV_42__2_PRE (Int) Bool)
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int)) (not (and (and (and (and (and (and (and (not (= (+ A B) (+ C D))) (>= C 0)) (= (+ B (- 1)) E)) (= (+ D (- 1)) F)) (INV_REC_tr^tr E F A C)) (>= (+ D (- 1)) 0)) (>= (+ B (- 1)) 0)) (= B D)))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int)) (not (and (and (and (and (and (and (and (not (= (+ A B) C)) (not (>= C 0))) (= (+ B (- 1)) D)) (= (+ E (- 1)) F)) (INV_REC_tr^tr D F A C)) (>= (+ E (- 1)) 0)) (>= (+ B (- 1)) 0)) (= B E)))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (and (= (+ C (- 1)) A) (= (+ D (- 1)) B)) (>= (+ D (- 1)) 0)) (>= (+ C (- 1)) 0)) (= C D)) (INV_REC_tr^tr_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int)) (not (and (and (and (and (and (not (= (+ A B) 0)) (= (+ B (- 1)) C)) (INV_REC_tr__1 C A)) (not (>= (+ D (- 1)) 0))) (>= (+ B (- 1)) 0)) (= B D)))))
(assert (forall ((A Int) (B Int) (C Int))(=> (and (and (and (= (+ B (- 1)) A) (not (>= (+ C (- 1)) 0))) (>= (+ B (- 1)) 0)) (= B C)) (INV_REC_tr__1_PRE A))))
(assert (forall ((A Int) (B Int) (C Int) (D Int)) (not (and (and (and (and (and (and (not (= (* (- 1) (+ A B)) 0)) (>= A 0)) (= (+ B (- 1)) C)) (INV_REC_tr__2 C A)) (>= (+ B (- 1)) 0)) (not (>= (+ D (- 1)) 0))) (= D B)))))
(assert (forall ((A Int) (B Int) (C Int) (D Int)) (not (and (and (and (and (and (and (not (= (* (- 1) A) 0)) (not (>= A 0))) (= (+ B (- 1)) C)) (INV_REC_tr__2 C A)) (>= (+ B (- 1)) 0)) (not (>= (+ D (- 1)) 0))) (= D B)))))
(assert (forall ((A Int) (B Int) (C Int))(=> (and (and (and (= (+ B (- 1)) A) (>= (+ B (- 1)) 0)) (not (>= (+ C (- 1)) 0))) (= C B)) (INV_REC_tr__2_PRE A))))
(assert (not false))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (INV_42 A B C D) (INV_REC_tr^tr_PRE A B)) (INV_REC_tr^tr A B C D))))
(assert (forall ((A Int) (B Int))(=> (INV_REC_tr^tr_PRE A B) (INV_42_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (and (= (* (- 1) C) 0) (= (* (- 1) D) 0)) (not (>= (+ B (- 1)) 0))) (not (>= (+ A (- 1)) 0))) (INV_42_PRE A B)) (INV_42 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (INV_42 A B C D) (>= (+ B (- 1)) 0)) (>= (+ A (- 1)) 0)) (INV_42_PRE A B)) (INV_42 A B C D))))
(assert (forall ((A Int) (B Int))(=> (and (and (>= (+ B (- 1)) 0) (>= (+ A (- 1)) 0)) (INV_42_PRE A B)) (INV_42_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (INV_42 A B C D) (not (>= (+ B (- 1)) 0))) (>= (+ A (- 1)) 0)) (INV_42_PRE A B)) (INV_42 A B C D))))
(assert (forall ((A Int) (B Int))(=> (and (and (not (>= (+ B (- 1)) 0)) (>= (+ A (- 1)) 0)) (INV_42_PRE A B)) (INV_42_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (INV_42 A B C D) (not (>= (+ A (- 1)) 0))) (>= (+ B (- 1)) 0)) (INV_42_PRE A B)) (INV_42 A B C D))))
(assert (forall ((A Int) (B Int))(=> (and (and (not (>= (+ A (- 1)) 0)) (>= (+ B (- 1)) 0)) (INV_42_PRE A B)) (INV_42_PRE A B))))
(assert (forall ((A Int) (B Int))(=> (and (INV_42__1 A B) (INV_REC_tr__1_PRE A)) (INV_REC_tr__1 A B))))
(assert (forall ((A Int) (B Int))(=> (and (and (= (* (- 1) B) 0) (not (>= (+ A (- 1)) 0))) (INV_42__1_PRE A)) (INV_42__1 A B))))
(assert (forall ((A Int) (B Int))(=> (and (and (INV_42__1 A B) (>= (+ A (- 1)) 0)) (INV_42__1_PRE A)) (INV_42__1 A B))))
(assert (forall ((A Int) (B Int))(=> (and (INV_42__2 A B) (INV_REC_tr__2_PRE A)) (INV_REC_tr__2 A B))))
(assert (forall ((A Int) (B Int))(=> (and (and (= (* (- 1) B) 0) (not (>= (+ A (- 1)) 0))) (INV_42__2_PRE A)) (INV_42__2 A B))))
(assert (forall ((A Int) (B Int))(=> (and (and (INV_42__2 A B) (>= (+ A (- 1)) 0)) (INV_42__2_PRE A)) (INV_42__2 A B))))
(check-sat)
