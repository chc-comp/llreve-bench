(set-info :origin "Horn problem converted to SMT-LIB2 using Eldarica (https://github.com/uuverifiers/eldarica)")
(set-logic HORN)
(declare-fun INV_MAIN_23 (Int Int Int Int Int) Bool)
(declare-fun INV_MAIN_42 (Int Int Int Int Int Int Int) Bool)
(declare-fun INV_MAIN_13 (Int Int Int Int) Bool)
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int))(=> (and (and (and (and (= (* (- 1) E) 0) (not (>= (+ F (- 1)) 0))) (= A C)) (= G B)) (= F D)) (INV_MAIN_23 A B C D E))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int))(=> (and (and (and (and (and (= (* (- 1) C) 0) (= (* (- 1) G) 0)) (>= (+ H (- 1)) 0)) (= B E)) (= A D)) (= H F)) (INV_MAIN_42 A B C D E F G))))
(assert (forall ((A Int) (B Int) (C Int) (D Int)) (not (and (and (and (not (= A B)) (not (>= (+ C (- 1)) 0))) (not (>= (+ D (- 1)) 0))) (INV_MAIN_13 D A C B)))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int))(=> (and (and (and (and (and (and (= (+ E (- 1)) A) (= (+ F 2) B)) (= (+ G (- 1)) C)) (= (+ H 2) D)) (>= (+ G (- 1)) 0)) (>= (+ E (- 1)) 0)) (INV_MAIN_13 E F G H)) (INV_MAIN_13 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (and (and (= (+ E (- 1)) A) (= (+ F 2) B)) (not (>= (+ C (- 1)) 0))) (>= (+ E (- 1)) 0)) (INV_MAIN_13 E F C D)) (INV_MAIN_13 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (and (and (= (+ E (- 1)) C) (= (+ F 2) D)) (not (>= (+ A (- 1)) 0))) (>= (+ E (- 1)) 0)) (INV_MAIN_13 A B E F)) (INV_MAIN_13 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (= (* (- 1) B) 0) (not (>= (+ E (- 1)) 0))) (INV_MAIN_23 A E C F D)) (INV_MAIN_13 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int))(=> (and (and (and (and (= (+ F (- 1)) B) (= (+ G 1) E)) (>= (+ D (- 1)) 0)) (>= (+ F (- 1)) 0)) (INV_MAIN_23 A F C D G)) (INV_MAIN_23 A B C D E))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (and (= (+ F (- 1)) B) (not (>= (+ D (- 1)) 0))) (>= (+ F (- 1)) 0)) (INV_MAIN_23 A F C D E)) (INV_MAIN_23 A B C D E))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int))(=> (and (and (not (>= (+ E (- 1)) 0)) (not (>= (+ F (- 1)) 0))) (INV_MAIN_42 F A B E C G D)) (INV_MAIN_13 A B C D))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int) (J Int))(=> (and (and (and (and (and (and (= (+ H (- 1)) A) (= (+ I 1) C)) (= (+ J (- 1)) D)) (not (>= (+ F (- 1)) 0))) (>= (+ J (- 1)) 0)) (>= (+ H (- 1)) 0)) (INV_MAIN_42 H B I J E F G)) (INV_MAIN_42 A B C D E F G))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int) (J Int) (K Int))(=> (and (and (and (and (and (and (and (= (+ H (- 1)) A) (= (+ I 1) C)) (= (+ J (- 1)) D)) (= (+ K 1) G)) (>= (+ F (- 1)) 0)) (>= (+ J (- 1)) 0)) (>= (+ H (- 1)) 0)) (INV_MAIN_42 H B I J E F K)) (INV_MAIN_42 A B C D E F G))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int))(=> (and (and (and (and (= (+ H (- 1)) A) (= (+ I 1) C)) (not (>= (+ D (- 1)) 0))) (>= (+ H (- 1)) 0)) (INV_MAIN_42 H B I D E F G)) (INV_MAIN_42 A B C D E F G))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int))(=> (and (and (and (and (= (+ H (- 1)) D) (not (>= (+ F (- 1)) 0))) (not (>= (+ A (- 1)) 0))) (>= (+ H (- 1)) 0)) (INV_MAIN_42 A B C H E F G)) (INV_MAIN_42 A B C D E F G))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int))(=> (and (and (and (and (and (= (+ H (- 1)) D) (= (+ I 1) G)) (>= (+ F (- 1)) 0)) (not (>= (+ A (- 1)) 0))) (>= (+ H (- 1)) 0)) (INV_MAIN_42 A B C H E F I)) (INV_MAIN_42 A B C D E F G))))
(check-sat)
