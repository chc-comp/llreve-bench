(set-info :origin "Horn problem converted to SMT-LIB2 using Eldarica (https://github.com/uuverifiers/eldarica)")
(set-logic HORN)
(declare-fun INV_REC_g^g (Int Int Int Int Int) Bool)
(declare-fun INV_REC_g^g_PRE (Int Int Int) Bool)
(declare-fun INV_REC_g__2 (Int Int Int) Bool)
(declare-fun INV_REC_g__2_PRE (Int Int) Bool)
(declare-fun INV_REC_g__1 (Int Int) Bool)
(declare-fun INV_REC_g__1_PRE (Int) Bool)
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int)) (not (and (and (and (not (= A B)) (= (* (- 1) C) 0)) (INV_REC_g^g D E C A B)) (= D E)))))
(assert (forall ((A Int) (B Int) (C Int))(=> (and (= (* (- 1) C) 0) (= A B)) (INV_REC_g^g_PRE A B C))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (= (* (- 1) D) 0) (<= B 0)) (<= A 0)) (INV_REC_g^g_PRE A B C)) (INV_REC_g^g A B C D C))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int))(=> (and (and (and (and (and (and (= (* (- 1) D) 0) (= (+ B (- 1)) F)) (= (+ B C) G)) (INV_REC_g__2 F G E)) (not (<= B 0))) (<= A 0)) (INV_REC_g^g_PRE A B C)) (INV_REC_g^g A B C D E))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int))(=> (and (and (and (and (= (+ C (- 1)) A) (= (+ C D) B)) (not (<= C 0))) (<= E 0)) (INV_REC_g^g_PRE E C D)) (INV_REC_g__2_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (and (and (and (= (+ A E) D) (= (+ A (- 1)) F)) (INV_REC_g__1 F E)) (<= B 0)) (not (<= A 0))) (INV_REC_g^g_PRE A B C)) (INV_REC_g^g A B C D C))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (= (+ B (- 1)) A) (<= C 0)) (not (<= B 0))) (INV_REC_g^g_PRE B C D)) (INV_REC_g__1_PRE A))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int))(=> (and (and (and (and (and (and (and (= (+ A F) D) (= (+ A (- 1)) G)) (= (+ B (- 1)) H)) (= (+ B C) I)) (INV_REC_g^g G H I F E)) (not (<= B 0))) (not (<= A 0))) (INV_REC_g^g_PRE A B C)) (INV_REC_g^g A B C D E))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int) (F Int))(=> (and (and (and (and (and (= (+ D (- 1)) A) (= (+ E (- 1)) B)) (= (+ E F) C)) (not (<= E 0))) (not (<= D 0))) (INV_REC_g^g_PRE D E F)) (INV_REC_g^g_PRE A B C))))
(assert (forall ((A Int) (B Int))(=> (and (and (= (* (- 1) B) 0) (<= A 0)) (INV_REC_g__1_PRE A)) (INV_REC_g__1 A B))))
(assert (forall ((A Int) (B Int))(=> (and (and (= (+ B (- 1)) A) (not (<= B 0))) (INV_REC_g__1_PRE B)) (INV_REC_g__1_PRE A))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (and (= (+ A C) B) (= (+ A (- 1)) D)) (INV_REC_g__1 D C)) (not (<= A 0))) (INV_REC_g__1_PRE A)) (INV_REC_g__1 A B))))
(assert (forall ((A Int) (B Int))(=> (and (<= A 0) (INV_REC_g__2_PRE A B)) (INV_REC_g__2 A B B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int))(=> (and (and (and (= (+ C (- 1)) A) (= (+ C D) B)) (not (<= C 0))) (INV_REC_g__2_PRE C D)) (INV_REC_g__2_PRE A B))))
(assert (forall ((A Int) (B Int) (C Int) (D Int) (E Int))(=> (and (and (and (and (= (+ A (- 1)) D) (= (+ A B) E)) (INV_REC_g__2 D E C)) (not (<= A 0))) (INV_REC_g__2_PRE A B)) (INV_REC_g__2 A B C))))
(check-sat)
